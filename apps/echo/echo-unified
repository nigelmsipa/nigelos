#!/usr/bin/env python3
"""
Echo - Unified Speech-to-Text Launcher
Intelligent launcher that adapts to how it's called:
- From terminal: notifications only
- From rofi/dmenu: notifications only  
- From desktop: optional GUI if needed
- Always manages the same background daemon
"""

import subprocess
import sys
import os
import signal
import time
import tkinter as tk
from tkinter import ttk
from pathlib import Path

class EchoUnified:
    def __init__(self):
        self.daemon_script = Path(__file__).parent / "echo_daemon_final.py"
        self.pid_file = Path.home() / ".cache" / "echo_daemon.pid"
        self.pid_file.parent.mkdir(exist_ok=True)
        
        # Detect launch context
        self.launched_from_gui = self._detect_gui_launch()
        self.show_gui = False  # We'll determine this intelligently
    
    def _detect_gui_launch(self):
        """Detect if launched from GUI context (rofi, desktop, etc.)"""
        # Check if we have a display but no controlling terminal
        has_display = os.environ.get('DISPLAY') is not None
        has_terminal = os.isatty(sys.stdin.fileno())
        
        # Check parent process name for rofi/launcher
        try:
            ppid = os.getppid()
            parent_cmd = subprocess.check_output(['ps', '-p', str(ppid), '-o', 'comm='], 
                                               stderr=subprocess.DEVNULL).decode().strip()
            is_launcher = any(launcher in parent_cmd.lower() 
                            for launcher in ['rofi', 'dmenu', 'launcher', 'wofi'])
        except:
            is_launcher = False
        
        return has_display and (not has_terminal or is_launcher)
    
    def _notify(self, title, message, icon="dialog-information", urgency="normal"):
        """Send desktop notification with appropriate urgency"""
        try:
            subprocess.run(['notify-send', '-i', icon, '-u', urgency, title, message], 
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except:
            pass
    
    def is_running(self):
        """Check if daemon is already running"""
        if not self.pid_file.exists():
            return False
        
        try:
            with open(self.pid_file, 'r') as f:
                pid = int(f.read().strip())
            os.kill(pid, 0)
            return True
        except (OSError, ValueError):
            self.pid_file.unlink(missing_ok=True)
            return False
    
    def start_daemon(self):
        """Start the Echo daemon"""
        if self.is_running():
            self._notify("Echo Already Running", 
                        "ðŸŽ¤ Speech-to-text is already active\nPress RIGHT CTRL to record", 
                        "audio-input-microphone", "low")
            return True
        
        try:
            process = subprocess.Popen([
                sys.executable, str(self.daemon_script)
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, 
               start_new_session=True)
            
            with open(self.pid_file, 'w') as f:
                f.write(str(process.pid))
            
            time.sleep(0.5)
            
            if process.poll() is None:
                self._notify("Echo Started", 
                           "ðŸŽ¤ Speech-to-text activated!\nPress and hold RIGHT CTRL to record", 
                           "audio-input-microphone", "normal")
                return True
            else:
                self._notify("Echo Failed", "âŒ Failed to start speech-to-text daemon", 
                           "dialog-error", "critical")
                self.pid_file.unlink(missing_ok=True)
                return False
                
        except Exception as e:
            self._notify("Echo Error", f"âŒ Error: {e}", "dialog-error", "critical")
            return False
    
    def stop_daemon(self):
        """Stop the Echo daemon"""
        if not self.is_running():
            self._notify("Echo Not Running", 
                        "ðŸ”‡ Speech-to-text is not active", 
                        "dialog-information", "low")
            return True
        
        try:
            with open(self.pid_file, 'r') as f:
                pid = int(f.read().strip())
            
            os.kill(pid, signal.SIGTERM)
            time.sleep(0.5)
            
            try:
                os.kill(pid, signal.SIGKILL)
            except OSError:
                pass
            
            self.pid_file.unlink(missing_ok=True)
            self._notify("Echo Stopped", 
                        "ðŸ”‡ Speech-to-text deactivated", 
                        "audio-input-microphone", "low")
            return True
            
        except Exception as e:
            self._notify("Echo Error", f"âŒ Error stopping: {e}", "dialog-error", "critical")
            return False
    
    def show_status_gui(self):
        """Show a minimal status GUI when appropriate"""
        root = tk.Tk()
        root.title("Echo Status")
        root.geometry("300x150")
        root.resizable(False, False)
        
        # Center the window
        root.update_idletasks()
        x = (root.winfo_screenwidth() // 2) - (300 // 2)
        y = (root.winfo_screenheight() // 2) - (150 // 2)
        root.geometry(f"300x150+{x}+{y}")
        
        frame = ttk.Frame(root, padding="20")
        frame.pack(fill=tk.BOTH, expand=True)
        
        # Status
        is_running = self.is_running()
        status_text = "ðŸŽ¤ Echo is ACTIVE" if is_running else "ðŸ”‡ Echo is INACTIVE"
        status_color = "green" if is_running else "red"
        
        status_label = ttk.Label(frame, text=status_text, font=("Arial", 12, "bold"))
        status_label.pack(pady=10)
        
        if is_running:
            help_label = ttk.Label(frame, text="Press and hold RIGHT CTRL to record speech", 
                                 font=("Arial", 9))
            help_label.pack(pady=5)
        
        # Buttons
        button_frame = ttk.Frame(frame)
        button_frame.pack(pady=10)
        
        if is_running:
            stop_btn = ttk.Button(button_frame, text="Stop Echo", 
                                command=lambda: (self.stop_daemon(), root.destroy()))
            stop_btn.pack(side=tk.LEFT, padx=5)
        else:
            start_btn = ttk.Button(button_frame, text="Start Echo", 
                                 command=lambda: (self.start_daemon(), root.destroy()))
            start_btn.pack(side=tk.LEFT, padx=5)
        
        close_btn = ttk.Button(button_frame, text="Close", command=root.destroy)
        close_btn.pack(side=tk.LEFT, padx=5)
        
        # Auto-close after 5 seconds if launched from GUI
        if self.launched_from_gui:
            root.after(5000, root.destroy)
        
        root.mainloop()
    
    def run(self):
        """Main entry point - intelligent behavior based on context and arguments"""
        args = sys.argv[1:] if len(sys.argv) > 1 else []
        
        # Handle explicit commands
        if args:
            command = args[0].lower()
            if command in ['start', 'on']:
                self.start_daemon()
            elif command in ['stop', 'off']:
                self.stop_daemon()
            elif command in ['status', 'check']:
                if self.launched_from_gui or '--gui' in args:
                    self.show_status_gui()
                else:
                    status = "running" if self.is_running() else "not running"
                    self._notify("Echo Status", f"ðŸŽ¤ Echo daemon is {status}", 
                               "audio-input-microphone")
            elif command in ['toggle']:
                if self.is_running():
                    self.stop_daemon()
                else:
                    self.start_daemon()
            elif command in ['restart']:
                self.stop_daemon()
                time.sleep(1)
                self.start_daemon()
            elif command in ['gui']:
                self.show_status_gui()
            else:
                print("Usage: echo [start|stop|status|toggle|restart|gui]")
                return
        else:
            # No arguments - intelligent default behavior
            if self.launched_from_gui:
                # From rofi/desktop: toggle daemon + brief notification
                if self.is_running():
                    self.stop_daemon()
                else:
                    self.start_daemon()
            else:
                # From terminal: show status and toggle
                current_status = "running" if self.is_running() else "stopped"
                print(f"Echo daemon is currently: {current_status}")
                
                if self.is_running():
                    self.stop_daemon()
                else:
                    self.start_daemon()

def main():
    echo = EchoUnified()
    echo.run()

if __name__ == "__main__":
    main()
